### 高级定时器
使用 setTimeout() 和 setInterval() 创建的定时器，容易误解为是线程，其实 JavaScript 是运行于单线程的环境中的，而定时器仅仅只是计划代码在未来的某个时间执行。**执行时间是不能保证的**，因为在页面的生命周期中，不同时间可能有其他代码在控制 JavaScript 进程。

在页面下载完成后的代码运行、事件处理程序、Ajax 回调函数都必须使用同样的线程来执行，实际上，浏览器负责进行排序，指派某段代码在某个时间点运行的 **优先级**。

可以把 JavaScript 想象成在时间线上运行的。当页面载入时，首先执行是任何包含在 script 元素中的代码，通常是页面生命周期后面要用到的一些简单的函数和变量的声明，有时候也包含一些初始数据的处理。在这之后，JavaScript 进程将等待更多代码执行。当进程空闲时，下一个代码会被触发并立刻执行。

除了主 JavaScript 执行进程外，还有 **一个需要在进程下一次空闲时执行的代码队列**。随着页面在其生命周期中的推移，代码会按照执行顺序添加入队列。（有哪些方式？）

例如，当某个按钮被按下时，它的事件处理程序代码就会被添加到队列中，并在下一个可能的事件里执行。当接收到某个 Ajax 响应时，回调函数的代码会被添加到队列。

**在 JavaScript 中没有任何代码是立刻执行的，但一旦进程空闲则尽快执行。**

定时器对队列的工作方式是，**当特定时间过去后将代码插入**。

注意，给队列添加代码并不意味着对它立刻执行，而只能表示它会尽快执行。（队列谁来管理？不占线程吗？）

关于定时器要记住的最重要的事情是，**指定的时间间隔表示何时将定时器的代码添加到队列，而不是何时实际执行代码**。队列中所有的代码都要等到 JavaScript 进程空闲之后才能执行，而不管它们是如何添加到队列中的。

执行完一套代码后，JavaScript 进程返回一段很短的时间，这样页面上的其他处理就可以进行了。由于 JavaScript 进程会阻塞其他页面处理，所以必须有这些小间隔来防止用户界面被锁定（代码长时间运行中还有可能出现）。这样设置一个定时器，可以确保在定时器代码执行前至少有一个时间间隔。

#### 重复的定时器
使用 setInterval() 创建的定时器确保了定时器代码规则地插入队列中。这个方式的问题在于，定时器代码可能在代码再次被添加到队列之前还没有完成执行，结果导致定时器代码连续运行好几次，而之间没有任何停顿。幸好，JavaScript 引擎够聪明，能避免这个问题，当使用 setInterval() 时，仅当没有该定时器的任何其他代码实例时，才将定时器代码添加到队列中。这确保了定时器代码加入到队列中的最小时间间隔为指定间隔。

这种重复定时器的规则有两个问题：
- 某些间隔会被跳过
- 多个定时器的代码执行之间的间隔可能会比预期的小

为了避免 setInterval() 的重复定时器的缺点，可以使用 `链式 setTimeout() 调用的模式`：
```javascript
setTimeout(function(){
    // 处理中
    setTimeout(arguments.callee, interval); // arguments.callee 获取当前执行函数的引用
}, interval);
```

这样做的好处是在前一个定时器代码执行完之前，不会向队列插入新的定时器代码，确保不会有任何缺失的间隔。而且，他可以保证在下一次定时器代码执行之前，至少要等待指定的间隔，避免了连续的运行。

每个浏览器窗口、标签页或者 frame 都有其各自的代码执行队列。进行跨 frame 或者跨窗口的定时调用，当代码同时执行的时候可能会导致竞争条件。无论何时需要使用这种通信类型，最好是在接收 frame 或者窗口中创建一个定时器来执行代码。

#### Yielding Processes
运行在浏览器中的 JavaScript 都被分配了一个确定数量的资源。不同于桌面应用往往能够随意控制它们要的内存大小和处理器时间，JavaScript 被严格限制了，以防止恶意的 Web 程序员把用户的计算机搞挂了。

其中一个限制是长时间运行脚本的制约，如果代码运行超过特定的时间或者特定语句数量就不让它继续执行。否则会弹出一个浏览器错误的对话框，告诉用户某个脚本会用过长的时间执行，询问是允许其继续执行还是停止它。因为就需要确保用户用户看不到这个对话框。定时器是绕开此限制的方法之一。

脚本长时间运行的问题通常是由两个原因之一造成的：
- 过长的、过深嵌套的函数调用
- 进行大量处理的循环

后者通常遵循的模式如下：
```javascript
for(var i = 0;i  < len; i++){
    process();
}
```

此模式的问题在于要处理的项目的数量在运行前是不可知的。

展开循环之前，需要明确：
- 改处理是否必须同步完成？
- 数据是否必须按顺序完成？

如果都是“否”，就可以使用 **定时器分割这个循环**，这是一种叫做 **数组分块（array chunking）**的技术：基本的思路是为要处理的项目创建一个队列，然后使用定时器取出下一个要处理的项目进行处理，接着再设置另一个定时器。基本模式如下：

```javascript
setTimeout(function(){
    // 取出下一个条目并处理
    var item = array.shift();
    process(item);

    // 若还有条目，再设置另一个定时器
    if(array.length > 0){
        setTimeout(arguments.callee, 100);
    }
}, 100);
```

在数组分块模式中，array 变量本质上就是一个“待办事宜”列表。

```javascript
function chunk(array, process, context){
    setTimeout(function(){
        var item = array.shift();
        process.call(context, item);

        if(array.length > 0){
            setTimeout(arguments.callee, 100);
        }
    }, 100);
}
```

需要注意的是，传递给 chunk() 的数组是用作一个队列的，因此当处理数据的同时，数组中的条目也在改变，如果向保持原数组不变，则应该将该数组的克隆传递给 chunk()：

```javascript
chunk(data.concat(), fn, this);
```

数组分块的重要性在于它可以将多个项目的处理在执行队列上分开，在每个项目处理之后，给予其它的浏览器处理机会运行，这样就可以避免长时间运行脚本的错误。

一旦某个函数需要花 50 ms 以上的时间完成，那么最好看看能否将任务分割为一系列可以使用定时器的小任务。

#### 函数节流
浏览器中某些计算和处理要比其他的昂贵很多，连续进行可能会导致浏览器挂起甚至崩溃（例如 DOM 操作） => 为了绕开这个问题，可以使用定时器对其（指函数、计算处理过程、事件处理程序等）进行 **节流**。

函数节流背后的基本思想是指，某些代码不可以在没有间断的情况下连续重复执行。

所以，第一次调用函数，创建一个定时器，在指定的时间间隔之后运行代码。在第二次调用该函数时，它会清除前一次的定时器并设置另一个。如果前一个定时器已经执行过了，这个操作就没有任何意义。然而，如果前一个定时器尚未执行，其实就是将其替换为一个新的定时器。目的是 **只有在执行函数的请求停止了一段时间之后才执行**，该模式基本形式如下：

```javascript
var processor = {
    timeoutId: null,

    // 实际进行处理的方法
    performProcessing: function(){
        // 实际执行的代码
    },

    // 初始处理调用的方法
    process: function(){
        clearTimeout(this.timeoutId);

        var that = this;
        this.timeoutId = setTimeout(function(){
            that.performProcessing();
        }, 100);    // 如果 100 ms 之内调用了 process() 共 20 次，performProcessing() 仍只会被调用一次
    }
}

processor.process();
```

简化版本：
```javascript
function throttle(method, context){
    clearTimeout(method.tId);
    method.tId = setTimeout(function(){
        method.call(context);
    }, 100);
```

对于事件而言，有些连续触发的事件（如scroll、resize等），最好控制处理的频率，以确保浏览器不会在极短的时间内进行过多的计算（控制事件处理程序的执行 => 因此造成页面卡死或缓慢的原因在于事件处理程序的执行，而不是事件本身的触发）。

**只要代码是周期执行的**，都应该使用节，都应该使用节流，但是你不能控制请求执行的速率（拿事件来说，即事件触发的频率）。